Pattern matching and text searching are very important components of many problems including text editing data retrieval and symbol manipulation The problem consists in finding occurrences of a given pattern in a long string the text Important variations of pattern matching are given by pre processing or not pre processing the text building an index and by the language used to specify the query In this paper we are interested in the pre processing case when the query is specified by a regular expression Formally given the text string and a regular In general these problems do not have the same complexity As we are interested in starting positions for a match it is enough to find the shortest string that matches in a given position We assume that is not a member form If it is the answer is trivial all values formare possible The traditional approach for searching text for matches of a regular expression is to use the finite automaton that recognizes the language defined by the regular expression Thompson with the text as input The main problems with this approach are more info
In the following comparisons it is assumed that the keys are of length k and the data structure contains n members
Unlike balanced trees radix trees permit lookup insertion and deletion in O time rather than Olog n This does not seem like an advantage since normally k more than log n  but in a balanced tree every comparison is a string comparison requiring O worst case time many of which are slow in practice due to long common prefixes in the case where comparisons begin at the start of the string In a trie all comparisons require constant time but it takes  m comparisons to look up a string of length m Radix trees can perform these operations with fewer comparisons and require many fewer nodes
Radix trees also share the disadvantages of tries however as they can only be applied to strings of elements or elements with an efficiently reversible mapping to strings they lack the full generality of balanced search trees which apply to any data type with a total ordering  A reversible mapping to strings can be used to produce the required total ordering for balanced search trees but not the other way around This can also be problematic if a data type only provides a comparison operation but not a de serialization operation
hash tables are commonly said to have expected Oone insertion and deletion times but this is only true when considering computation of the hash of the key to be a constant time operation When hashing the key is taken into account hash tables have expected O insertion and deletion times but may take longer in the worst case depending on how collisions are handled Radix trees have worst case O insertion and deletion The successor predecessor operations of radix trees are also not implemented by hash tables A common extension of radix trees uses two colors of nodes black and white To check if a given string is stored in the tree the search starts from the top and follows the edges of the input string until no further progress can be made If the search string is consumed and the final node is a black node the search has failed if it is white the search has succeeded This enables us to add a large range of strings with a common prefix to the tree using white nodes then remove a small set of exceptions in a space efficient manner by inserting them using black nodes The HAT tries is a cache conscious data structure based on radix trees that offers efficient string storage and retrieval and ordered iterations Performance with respect to both time and space is comparable to the cache conscious hastable See HAT trie implementation notes at
A PATRICIA trie is a special variant of the radix two binary trie in which rather than explicitly store every bit of every key the nodes store only the position of the first bit which differentiates two sub trees During traversal the algorithm examines the indexed bit of the search key and chooses the left or right sub tree as appropriate Notable features of the PATRICIA trie include that the trie only requires one node to be inserted for every unique key stored making PATRICIA much more compact than a standard binary trie Also since the actual keys are no longer explicitly stored it is necessary to perform one full key comparison on the indexed record in order to confirm a match In this respect PATRICIA bears a certain resemblance to indexing using a hash table
The adaptative radix tree is a radix tree variant that integrates adaptive node sizes to the radix tree One major drawback of the usual radix trees is the use of space because it uses a constant node size in every level The major difference between the radix tree and the adaptive radix tree is its variable size for each node based on the number of child elements which grows while adding new entries Hence the adaptive radix tree leads to a better use of space without reducing its speed A common practice is to relax the criteria of disallowing parents with only one child in situations where the parent represents a valid key in the data set This variant of radix tree achieves a higher space efficiency than the one which only allows internal nodes with at least two children





